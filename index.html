<!DOCTYPE html>
<html lang="en">
<head>
  <title>Tiny Breakout</title>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Tiny Braille Bar by RGBKnights. Play breakout in your URL bar.">
  <meta property="og:locale" content="en_US" />
	<meta property="og:type" content="article" />
  <meta property="og:url" content="https://bb.rgbknights.com/">
  <meta property="og:type" content="article">
  <meta property="og:site_name" content="RGBKnights" />
  <meta property="og:title" content="Tiny BREAKOUT - RGBKnights">
  <meta property="og:description" content="Tiny Braille Bar by RGBKnights. Play breakout in your URL bar.">
  <meta property="og:image" content="https://bb.rgbknights.com/card-01.png">
  <meta property="og:image:width" content="600" />
	<meta property="og:image:height" content="319" />
  <meta property="og:image:type" content="image/png" />
  <meta name="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://bb.rgbknights.com/">
  <meta name="twitter:title" content="Tiny BREAKOUT - RGBKnights">
  <meta name="twitter:description" content="Tiny Braille Bar by RGBKnights. Play breakout in your URL bar.">
  <meta name="twitter:image" content="https://bb.rgbknights.com/card-01.png">
  <style>
    body {
      margin: 0 !important;
      font-family: system-ui, sans-serif;
      background: #2D2D2F;
      color: #e8edf7;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      text-align: center;
    }
    main {
      max-width: 600px;
    }
    .logo {
      width: 600px;
    }
  </style>
</head>
<body>
  <main>
    <img src="card-01.png" class="logo" />
    <p>Use <strong>‚Üë</strong>/<strong>‚Üì</strong> (or <strong>W</strong>/<strong>S</strong>) to move the single-dot paddle up and down the four braille rows. Press <strong>R</strong> to restart.</p>
    <p>The entire game renders inside the browser URL bar: the paddle hugs the left, the ball travels horizontally, and bricks sit on the right.</p>
    <p>If you miss the ball its <span title="Game Over">üíÄ</span> can you clear all the blocks and claim <span title="Victory">üèÜ</span></p>
  </main>
  <script>
    (() => {
      const WIDTH = 16; // keep braille line short enough for URL bar
      const HEIGHT = 4;
      const PADDLE_X = 0;
      const EMPTY_CHAR = String.fromCodePoint(0x2007); // figure space stays visible without %20 encoding
      const BRICK_START = 5; // small padding then mostly blocks
      const BRICK_COLS = Math.max(1, WIDTH - BRICK_START);
      const DOT_BITS = [0x1, 0x2, 0x4, 0x40]; // braille dots 1,2,3,7 (left column, four high)
      const ROW_MASK = (1 << HEIGHT) - 1;

      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

      const randomNudgeY = (y) => {
        const delta = Math.random() < 0.5 ? -1 : 1;
        const nudged = clamp(y + delta, 0, HEIGHT - 1);
        if (nudged === y && (y === 0 || y === HEIGHT - 1)) {
          return clamp(y - delta, 0, HEIGHT - 1);
        }
        return nudged;
      };

      const buildBricks = () => {
        const cols = Array(WIDTH).fill("0");
        for (let x = BRICK_START; x < WIDTH; x++) cols[x] = "f";
        return cols.join("");
      };

      const defaultState = () => {
        const startY = Math.floor(HEIGHT / 2);
        return {
          bX: PADDLE_X, // start on the paddle
          bY: startY,
          bDX: 1, // head right to start
          bDY: 1,
          pY: startY,
          br: buildBricks(),
          tick: 0,
          score: 0,
          over: false,
          win: false,
        };
      };

      const toBraille = (mask) => {
        let brailleMask = 0;
        for (let i = 0; i < HEIGHT; i += 1) {
          if (mask & (1 << i)) brailleMask |= DOT_BITS[i];
        }
        return String.fromCodePoint(0x2800 | brailleMask);
      };

      let state = defaultState();
      const pressed = new Set();

      const brickMaskAt = (x) => Number.parseInt(state.br[x] || "0", 16) & ROW_MASK;

      const renderUrl = () => {
        const ballChar = toBraille(1 << state.bY);
        const row = Array.from(state.br).map((cell, x) => {
          let mask = Number.parseInt(cell, 16) & ROW_MASK;
          const hasPaddle = x === PADDLE_X;
          const hasBall = x === state.bX;
          if (hasPaddle) mask |= 1 << state.pY;
          if (hasBall) mask |= 1 << state.bY;
          const char = mask ? toBraille(mask) : EMPTY_CHAR;
          const onlyBall = hasBall && !hasPaddle && mask === (1 << state.bY);
          return onlyBall ? ballChar : char;
        });

        const renderLine = row.join("");
        const frameLabel = `${renderLine}${state.over ? "üíÄ" : state.win ? "üèÜ" : ""}`;
        history.replaceState(null, "", `#${frameLabel}`);
      };

      const reset = () => {
        state = defaultState();
        renderUrl();
      };

      const handleInput = () => {
        if (pressed.has("ArrowUp") || pressed.has("w")) {
          state.pY = clamp(state.pY - 1, 0, HEIGHT - 1);
        }
        if (pressed.has("ArrowDown") || pressed.has("s")) {
          state.pY = clamp(state.pY + 1, 0, HEIGHT - 1);
        }
      };

      let loopId = null;
      let inputLoopId = null;

      const tick = () => {
        if (state.over || state.win) {
          renderUrl();
          return;
        }

        let nextX = state.bX + state.bDX;
        let nextY = state.bY + state.bDY;

        if (nextY > HEIGHT - 1 || nextY < 0) {
          state.bDY *= -1;
          nextY = clamp(state.bY + state.bDY, 0, HEIGHT - 1);
        }

        if (nextX >= WIDTH) {
          state.bDX = -1;
          nextX = WIDTH - 1;
        }

        if (nextX < 0) {
          if (state.bY === state.pY) {
            state.bDX = 1;
            nextX = 0;
            nextY = randomNudgeY(nextY);
            state.bDY = Math.sign(nextY - state.bY) || state.bDY;
          } else {
            state.over = true;
          }
        }

        if (!state.over && nextX >= BRICK_START) {
          const mask = brickMaskAt(nextX);
          const brickBit = 1 << nextY;
          if (mask & brickBit) {
            const newMask = mask & ~brickBit;
            state.br =
              state.br.slice(0, nextX) + newMask.toString(16) + state.br.slice(nextX + 1);
            state.bDX = -1;
            nextY = randomNudgeY(nextY);
            state.bDY = Math.sign(nextY - state.bY) || state.bDY;
            state.score += 1;
            if (!/[1-9a-f]/i.test(state.br)) {
              state.win = true;
            }
          }
        }

        state.bX = nextX;
        state.bY = nextY;
        state.tick += 1;
        renderUrl();
      };

      window.addEventListener("keydown", (e) => {
        pressed.add(e.key);
        if (e.key.toLowerCase() === "r") {
          reset();
        }
      });

      window.addEventListener("keyup", (e) => pressed.delete(e.key));

      window.addEventListener("beforeunload", () => {
        clearInterval(loopId);
        clearInterval(inputLoopId);
        loopId = null;
        inputLoopId = null;
      });


      renderUrl();
      inputLoopId = setInterval(handleInput, 25);
      loopId = setInterval(tick, 160);
    })();
  </script>
</body>
</html>
