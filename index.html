<!DOCTYPE html>
<html lang="en">
<head>
  <title>Tiny Breakout</title>
  <meta charset="UTF-8" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ü•è</text></svg>">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Tiny Braille Bar. Play breakout in your URL bar.">
  <meta property="og:locale" content="en_US" />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="https://bb.rgbknights.com/">
  <meta property="og:site_name" content="RGBKnights" />
  <meta property="og:title" content="Tiny BREAKOUT - RGBKnights">
  <meta property="og:description" content="Tiny Braille. Play breakout in your URL bar.">
  <meta property="og:image" content="https://bb.rgbknights.com/card02.png">
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="319" />
  <meta property="og:image:type" content="image/png" />
  <meta name="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://bb.rgbknights.com/">
  <meta name="twitter:title" content="Tiny BREAKOUT - RGBKnights">
  <meta name="twitter:description" content="Tiny Braille Bar. Play breakout in your URL bar.">
  <meta name="twitter:image" content="https://bb.rgbknights.com/card02.png">
  <style>
    body {
      margin: 0 !important;
      font-family: system-ui, sans-serif;
      background: #292629;
      color: #e8edf7;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      text-align: center;
    }
    main {
      max-width: 600px;
    }
    .logo {
      width: 600px;
      max-width: 100%;
      height: auto;
      display: block;
      margin: 0 auto 1.5rem;
    }
    #start-btn {
      margin-top: 12px;
      padding: 12px 28px;
      font-size: 18px;
      font-weight: 700;
      letter-spacing: 0.02em;
      color: #0d0d0f;
      background: linear-gradient(135deg, #37D3FE, #3981BB);
      border: none;
      border-radius: 999px;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
      transition: transform 120ms ease, box-shadow 120ms ease, filter 120ms ease;
    }
    #start-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.3);
      filter: brightness(1.03);
    }
    #start-btn:active {
      transform: translateY(0);
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.2);
    }
    #touch-controls {
      position: fixed;
      right: 16px;
      bottom: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 10;
    }
    .touch-btn {
      width: 64px;
      height: 64px;
      font-size: 26px;
      font-weight: 700;
      color: #e8edf7;
      background: rgba(255, 255, 255, 0.12);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 14px;
      backdrop-filter: blur(6px);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
      cursor: pointer;
      touch-action: none;
      transition: transform 120ms ease, box-shadow 120ms ease, border-color 120ms ease;
    }
    .touch-btn:active {
      transform: translateY(1px);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.3);
      border-color: rgba(255, 255, 255, 0.35);
    }
    @media (pointer: coarse) {
      #start-btn {
        display: none;
      }
    }
  </style>
</head>
<body>
  <main>
    <img src="card02.png" class="logo" alt="Tiny Breakout social card" />
    <p>
      Use <strong>‚Üë</strong>/<strong>‚Üì</strong> (or <strong>W</strong>/<strong>S</strong>) to move the single-dot paddle up and down the four braille rows.
      Press <strong>Enter</strong> to start or reset.
    </p>
    <p>
      The entire game renders inside the browser URL bar: the paddle hugs the left, the ball travels horizontally,
      and bricks sit on the right.
    </p>
    <p>
      If you miss the ball its Game Over! <span title="Game Over">üíÄ</span>
      <br />
      Can you clear all the blocks and claim Victory! <span title="Victory">üèÜ</span>
    </p>
    <p>
      <button id="start-btn" type="button">Start</button>
    </p>
  </main>
  <script>
    (() => {
      const WIDTH = 32;
      const HEIGHT = 4;
      const PADDLE_X = 0;

      const BRICK_START = WIDTH / 4;
      const BRICK_COLS = Math.max(1, WIDTH - BRICK_START);
      const DOT_BITS = [0x1, 0x2, 0x4, 0x40];
      const ROW_MASK = (1 << HEIGHT) - 1;

      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

      const randomNudgeY = (y) => {
        const delta = Math.random() < 0.5 ? -1 : 1;
        const nudged = clamp(y + delta, 0, HEIGHT - 1);
        if (nudged === y && (y === 0 || y === HEIGHT - 1)) {
          return clamp(y - delta, 0, HEIGHT - 1);
        }
        return nudged;
      };

      const buildBricks = () => {
        const cols = Array(WIDTH).fill("0");
        for (let x = BRICK_START; x < WIDTH; x++) cols[x] = "f";
        return cols.join("");
      };

      const defaultState = () => {
        const startY = Math.floor(Math.random() * HEIGHT);
        return {
          bX: PADDLE_X,
          bY: startY,
          bDX: 1,
          bDY: 1,
          pY: startY,
          br: buildBricks(),
          tick: 0,
          score: 0,
          over: false,
          win: false,
        };
      };

      const toBraille = (mask) => {
        let brailleMask = 0;
        for (let i = 0; i < HEIGHT; i += 1) {
          if (mask & (1 << i)) brailleMask |= DOT_BITS[i];
        }
        return String.fromCodePoint(0x2800 | brailleMask);
      };

      let state = defaultState();
      const pressed = new Set();

      const brickMaskAt = (x) =>
        Number.parseInt(state.br[x] || "0", 16) & ROW_MASK;

      let loopId = null;
      let inputLoopId = null;

      const stopLoops = () => {
        clearInterval(loopId);
        clearInterval(inputLoopId);
        loopId = null;
        inputLoopId = null;
      };

      const movePaddle = (key) => {
        if (key === "ArrowUp" || key === "w") {
          state.pY = clamp(state.pY - 1, 0, HEIGHT - 1);
        }
        if (key === "ArrowDown" || key === "s") {
          state.pY = clamp(state.pY + 1, 0, HEIGHT - 1);
        }
      };

      const renderUrl = () => {
        const ballChar = toBraille(1 << state.bY);

        const row = Array.from(state.br).map((cell, x) => {
          let mask = Number.parseInt(cell, 16) & ROW_MASK;
          const hasPaddle = x === PADDLE_X;
          const hasBall = x === state.bX;

          if (hasPaddle) mask |= 1 << state.pY;
          if (hasBall) mask |= 1 << state.bY;

          // Empty cells render as double underscores to avoid URL encoding
          const char = mask ? toBraille(mask) : "__";

          const onlyBall =
            hasBall && !hasPaddle && mask === (1 << state.bY);
          return onlyBall ? ballChar : char;
        });

        const renderLine = row.join("");
        const frameLabel = `${state.over ? "üíÄ" : state.win ? "üèÜ" : "ü•è"}${renderLine}`;
        history.replaceState(null, "", `${frameLabel}`);
      };

      const reset = () => {
        state = defaultState();
        renderUrl();
      };

      const handleInput = () => {
        if (pressed.has("ArrowUp") || pressed.has("w")) movePaddle("ArrowUp");
        if (pressed.has("ArrowDown") || pressed.has("s")) movePaddle("ArrowDown");
      };

      const attachTouchControls = () => {
        const isTouchCapable =
          window.matchMedia("(pointer: coarse)").matches ||
          "ontouchstart" in window ||
          navigator.maxTouchPoints > 0;

        if (!isTouchCapable) return;

        const container = document.createElement("div");
        container.id = "touch-controls";

        const makeActionButton = (label, onPress, aria) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "touch-btn";
          btn.textContent = label;
          btn.setAttribute("aria-label", aria);

          btn.addEventListener("pointerdown", (e) => {
            e.preventDefault();
            onPress();
          });
          btn.addEventListener("click", (e) => e.preventDefault());

          return btn;
        };

        const makeButton = (label, key, aria) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "touch-btn";
          btn.textContent = label;
          btn.setAttribute("aria-label", aria);

          const press = (pointerType) => {
            const singleStep =
              pointerType === "touch" || pointerType === "pen" || !pointerType;
            if (singleStep) {
              movePaddle(key);
            } else {
              pressed.add(key);
              handleInput();
            }
          };
          const release = () => pressed.delete(key);

          btn.addEventListener("pointerdown", (e) => {
            e.preventDefault();
            press(e.pointerType);
          });
          btn.addEventListener("pointerup", release);
          btn.addEventListener("pointercancel", release);
          btn.addEventListener("pointerleave", release);
          btn.addEventListener("click", (e) => e.preventDefault());

          return btn;
        };

        container.append(
          makeActionButton("‚ü≥", startGame, "Start or restart game"),
          makeButton("‚Üë", "ArrowUp", "Move paddle up"),
          makeButton("‚Üì", "ArrowDown", "Move paddle down")
        );

        document.body.appendChild(container);
      };

      const tick = () => {
        if (state.over || state.win) {
          renderUrl();
          return;
        }

        let nextX = state.bX + state.bDX;
        let nextY = state.bY + state.bDY;

        if (nextY > HEIGHT - 1 || nextY < 0) {
          state.bDY *= -1;
          nextY = clamp(state.bY + state.bDY, 0, HEIGHT - 1);
        }

        if (nextX >= WIDTH) {
          state.bDX = -1;
          nextX = WIDTH - 1;
        }

        if (nextX < 0) {
          if (state.bY === state.pY) {
            state.bDX = 1;
            nextX = 0;
            nextY = randomNudgeY(nextY);
            state.bDY = Math.sign(nextY - state.bY) || state.bDY;
          } else {
            state.over = true;
          }
        }

        if (!state.over && nextX >= BRICK_START) {
          const mask = brickMaskAt(nextX);
          const brickBit = 1 << nextY;
          if (mask & brickBit) {
            const newMask = mask & ~brickBit;
            state.br =
              state.br.slice(0, nextX) +
              newMask.toString(16) +
              state.br.slice(nextX + 1);

            state.bDX = -1;
            nextY = randomNudgeY(nextY);
            state.bDY = Math.sign(nextY - state.bY) || state.bDY;
            state.score += 1;

            if (!/[1-9a-f]/i.test(state.br)) {
              state.win = true;
            }
          }
        }

        state.bX = nextX;
        state.bY = nextY;
        state.tick += 1;
        renderUrl();
      };

      const startGame = () => {
        stopLoops();
        pressed.clear();
        reset();
        inputLoopId = setInterval(handleInput, 100);
        loopId = setInterval(tick, 200);
      };

      window.addEventListener("keydown", (e) => {
        pressed.add(e.key);
        if (e.key === "Enter") {
          if (!loopId && !inputLoopId) startGame();
          else reset();
        }
      });

      window.addEventListener("keyup", (e) => pressed.delete(e.key));

      window.addEventListener("beforeunload", () => {
        stopLoops();
      });

      const startButton = document.getElementById("start-btn");
      if (startButton) startButton.addEventListener("click", startGame);

      attachTouchControls();
      renderUrl();
    })();
  </script>
</body>
</html>
